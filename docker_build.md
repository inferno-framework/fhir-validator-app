```yaml
name: Docker Build and Publish

on:
  push:
    branches:
      - main # or your main branch
  pull_request:
    branches:
      - main # or your main branch

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read # For checkout

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker builds
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/${{ github.event.repository.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix=sha-
            type=semver,pattern={{version}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
```

**Explanation and Key Improvements:**

1.  **`permissions`:**
    * The `permissions` section is crucial for security. `packages: write` allows the workflow to push images to the GitHub Container Registry. `contents: read` is needed for the checkout action.
2.  **`docker/login-action`:**
    * This step logs in to the GitHub Container Registry (ghcr.io) using the `GITHUB_TOKEN`. This token automatically provides authentication within your repository's context.
3.  **`docker/metadata-action`:**
    * This action is highly recommended. It automatically generates meaningful Docker tags and labels based on the Git context (branch, tag, commit SHA).
    * `images:` sets the name of the image with the correct ghcr path.
    * `tags:` defines the tagging strategy. The example tags the image with the branch name, tag name (if a tag is pushed), and the short SHA.
    * `type=semver,pattern={{version}}` is very useful if you use semantic versioning. if your git tags are valid semver, this will create tags based on those versions.
4.  **`docker/build-push-action`:**
    * This action builds the Docker image from the current directory (`context: .`) and pushes it to the registry.
    * `tags: ${{ steps.meta.outputs.tags }}` and `labels: ${{ steps.meta.outputs.labels }}` utilizes the tags and labels generated by the metadata action.
5.  **`on` trigger:**
    * The `on` trigger is set to run the workflow on `push` and `pull_request` events to the `main` branch. You can adjust this to fit your workflow.
6. **Error Handling:**
    * For more robust production workflows you should add error handling. For example, you can use `if: ${{ failure() }}` to send notifications upon failure.
7. **Dockerfile Location:**
    * This spec assumes your Dockerfile is in the root of your repository. If it's in a subdirectory, adjust the `context` in the `docker/build-push-action` step.

**How to Use:**

1.  **Create a `.github/workflows` directory** in your repository.
2.  **Create a YAML file** (e.g., `docker-publish.yml`) in the `.github/workflows` directory.
3.  **Copy and paste** the YAML code into the file.
4.  **Commit and push** the changes to your repository.

This setup will automatically build and publish your Docker image to the GitHub Container Registry whenever you push to the `main` branch or create a pull request targeting it.
